//! This module transforms the original code (with exec + proof + spec code)
//! into an abstracted version of the code (with only exec + proof code, no spec code)
//! for the purpose of checking ownership/lifetime/borrow on the exec and proof code.
//! (All spec code is erased because no ownership/lifetime/borrow checking should be
//! performed on spec code.)
//! This module then feeds the transformed code to rustc so that rustc can
//! catch any ownership/lifetime/borrow errors.

/*
The generated abstracted code discards much of the detail of the original code,
but keeps enough for ownership/lifetime/borrow checking.
Specifically it keeps:
- struct and enum declarations, and fields of the declarations
- lifetime ('a) and type (A) parameters, but not trait bounds (except for Copy, which is kept)
- functions, with impl methods turned into to top-level functions
- function bodies, but with external_body function bodies replaced with panic
  (external functions are erased completely)
- overall structure of blocks, statements, and expressions, but with specific operators
  transformed into calls to a generic function named "op"
- variable declarations and pattern matching
(The exact program elements that are kept can be seen in the abstract syntax defined in lifetime_ast.rs.)
For example, if the original code is the following:

    struct S {
    }

    spec fn fspec(i: u32, s1: S, s2: S) -> u32 {
        i
    }

    proof fn fproof(i: u32, tracked s1: S, tracked s2: S) -> u32 {
        i
    }

    fn fexec(i: u32, s1: S, s2: S) -> u32 {
        i
    }

    proof fn test_proof(i: u32, tracked s: S) {
        let j = fspec(i, s, s);
        let k = fproof(i, s, s);
    }

    fn test_exec(i: u32, s: S)
        requires i < 100
    {
        proof {
            let j = fspec(i, s, s);
            let k = fproof(i, s, s);
        }
        let k = fexec(i, s, s);
        let n = fexec(i, s, s);
    }

Then the generated "synthetic" Rust code will look like the following
(use the --log-all or --log-lifetime options to print the generated synthetic code
to a file in the .verus-log directory):

    struct D1_S {
    }

    fn f3_fproof(
        x4_i: (),
        x5_s1: D1_S,
        x6_s2: D1_S,
    )
    {
    }

    fn f8_fexec(
        x4_i: u32,
        x5_s1: D1_S,
        x6_s2: D1_S,
    ) -> u32
    {
        x4_i
    }

    fn f11_test_proof(
        x4_i: (),
        x9_s: D1_S,
    )
    {
        f3_fproof(op::<_, ()>(()), x9_s, x9_s, );
    }

    fn f15_test_exec(
        x4_i: u32,
        x9_s: D1_S,
    )
    {
        {
            f3_fproof(op::<_, ()>(()), x9_s, x9_s, );
        };
        let x12_k: u32 = f8_fexec(x4_i, x9_s, x9_s, );
        let x13_n: u32 = f8_fexec(x4_i, x9_s, x9_s, );
    }

When rustc is called on this generated code, rustc will report ownership violations
because the code tries to duplicate the linear variable "x9_s", which
corresponds to "s" in the original code.

When we print the error messages, we need to transform the line and column numbers
so that the error messages correspond to the original code.
These error messages are generated by running rustc on the synthetic code,
with rustc configured to generate errors in JSON format, capturing the JSON errors
and parsing them to retrieve the line/column information and error messages,
converting the synthetic line/column information back into spans for the original source code,
and then sending the error messages and spans to the rustc diagnostics for the original source code.
*/

// In functions executed through the lifetime rustc driver, use `ldbg!` for debug output.

use crate::erase::ErasureHints;
use crate::lifetime_emit::*;
use crate::lifetime_generate::*;
use crate::spans::SpanContext;
use crate::util::error;
use crate::verus_items::VerusItems;
use rustc_hir::{AssocItemKind, Crate, ItemKind, MaybeOwner, OwnerNode};
use rustc_middle::mir::BorrowCheckResult;
use rustc_middle::mir::HasLocalDecls;
use rustc_middle::mir::VarBindingForm;
use rustc_middle::ty::TyCtxt;
use rustc_query_system::dep_graph::DepNodeParams;
use rustc_span::Symbol;
use serde::{Deserialize, Serialize};
use std::fs::File;
use std::io::Write;
use vir::ast::VirErr;
use vir::messages::{message_bare, Message, MessageLevel};

const LDBG_PREFIX: &str = "!!!ldbg!!! ";

#[allow(unused)]
fn ldbg_prefix_all_lines(s: String) -> String {
    let mut s2 = s.lines().map(|l| LDBG_PREFIX.to_string() + l).fold(
        String::with_capacity(s.len()),
        |mut acc, l| {
            acc += &l;
            acc += "\n";
            acc
        },
    );
    s2.pop().unwrap();
    s2
}

// Derived from rust's std::dbg!
#[macro_export]
macro_rules! ldbg {
    // NOTE: We cannot use `concat!` to make a static string as a format argument
    // of `eprintln!` because `file!` could contain a `{` or
    // `$val` expression could be a block (`{ .. }`), in which case the `eprintln!`
    // will be malformed.
    () => {
        ::std::eprintln!("{}[lifetime {}:{}]", LDBG_PREFIX, $crate::file!(), $crate::line!())
    };
    ($val:expr $(,)?) => {
        // Use of `match` here is intentional because it affects the lifetimes
        // of temporaries - https://stackoverflow.com/a/48732525/1063961
        match $val {
            tmp => {
                let __string = ::std::format!("[lifetime {}:{}] {} = {:#?}", ::std::file!(), ::std::line!(), ::std::stringify!($val), &tmp);
                ::std::eprintln!("{}", $crate::lifetime::ldbg_prefix_all_lines(__string));
                tmp
            }
        }
    };
    ($($val:expr),+ $(,)?) => {
        ($(ldbg!($val)),+,)
    };
}

#[macro_export]
macro_rules! leprintln {
    ($val:expr) => {
        match $val {
            tmp => {
                let __string =
                    ::std::format!("[lifetime {}:{}] = {}", ::std::file!(), ::std::line!(), &tmp);
                ::std::eprintln!("{}", $crate::lifetime::ldbg_prefix_all_lines(__string));
                tmp
            }
        }
    };
}

// Call Rust's mir_borrowck to check lifetimes of #[spec] and #[proof] code and variables
pub(crate) fn check<'tcx>(queries: &'tcx rustc_interface::Queries<'tcx>) {
    // fn bck_analysis<'tcx>(def_id: rustc_span::def_id::DefId, bck_results: &BorrowCheckResult<'tcx>) {
    //     dbg!(&def_id, &bck_results);
    // }

    queries.global_ctxt().expect("global_ctxt").enter(|tcx| {
        let hir = tcx.hir();
        let krate = hir.krate();
        for owner in &krate.owners {
            if let MaybeOwner::Owner(owner) = owner {
                match owner.node() {
                    OwnerNode::Item(item) => match &item.kind {
                        rustc_hir::ItemKind::Fn(..) => {
                            tcx.ensure().mir_borrowck(item.owner_id.def_id);
                            // tcx.enter(|tcx| {
                            //     let bck_results = tcx.mir_borrowck(item.owner_id.def_id);
                            //     bck_analysis(item.owner_id.def_id.to_def_id(), &bck_results);
                            // })
                        }
                        ItemKind::Impl(impll) => {
                            for item in impll.items {
                                match item.kind {
                                    AssocItemKind::Fn { .. } => {
                                        tcx.ensure().mir_borrowck(item.id.owner_id.def_id);
                                        // tcx.enter(|tcx| {
                                        //     let bck_results = tcx.mir_borrowck(item.id.owner_id.def_id);
                                        //     bck_analysis(item.id.owner_id.def_id.to_def_id(), &bck_results);
                                        // })
                                    }
                                    _ => {}
                                }
                            }
                        }
                        _ => {}
                    },
                    _ => (),
                }
            }
        }
    });
}

const PRELUDE: &str = "\
#![feature(box_patterns)]
#![feature(rustc_attrs)]
#![allow(non_camel_case_types)]
#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(unused_assignments)]
#![allow(unreachable_patterns)]
#![allow(unused_parens)]
#![allow(unused_braces)]
#![allow(dead_code)]
#![allow(unreachable_code)]
#![allow(unconditional_recursion)]
#![allow(unused_mut)]
#![allow(unused_labels)]
#![allow(internal_features)]
use std::marker::PhantomData;
use std::rc::Rc;
use std::sync::Arc;
fn op<A, B>(a: A) -> B { panic!() }
#[rustc_diagnostic_item = \"verus::lifetime::resolve\"]
fn resolve<A>(a: A) { panic!() }
fn static_ref<T>(t: T) -> &'static T { panic!() }
fn tracked_new<T>(t: T) -> Tracked<T> { panic!() }
fn tracked_exec_borrow<'a, T>(t: &'a T) -> &'a Tracked<T> { panic!() }
fn clone<T>(t: &T) -> T { panic!() }
fn rc_new<T>(t: T) -> std::rc::Rc<T> { panic!() }
fn arc_new<T>(t: T) -> std::sync::Arc<T> { panic!() }
fn box_new<T>(t: T) -> Box<T> { panic!() }
struct Tracked<A> { a: PhantomData<A> }
impl<A> Tracked<A> {
    pub fn get(self) -> A { panic!() }
    pub fn borrow(&self) -> &A { panic!() }
    pub fn borrow_mut(&mut self) -> &mut A { panic!() }
}
struct Ghost<A> { a: PhantomData<A> }
impl<A> Clone for Ghost<A> { fn clone(&self) -> Self { panic!() } }
impl<A> Copy for Ghost<A> { }
#[derive(Clone, Copy)] struct int;
#[derive(Clone, Copy)] struct nat;
struct FnSpec<Args, Output> { x: PhantomData<(Args, Output)> }
struct InvariantBlockGuard;
fn open_atomic_invariant_begin<'a, X, V>(_inv: &'a X) -> (&'a InvariantBlockGuard, V) { panic!(); }
fn open_local_invariant_begin<'a, X, V>(_inv: &'a X) -> (&'a InvariantBlockGuard, V) { panic!(); }
fn open_invariant_end<V>(_guard: &InvariantBlockGuard, _v: V) { panic!() }
fn index<'a, V, Idx, Output>(v: &'a V, index: Idx) -> &'a Output { panic!() }
";

fn emit_check_tracked_lifetimes<'tcx>(
    cmd_line_args: crate::config::Args,
    tcx: TyCtxt<'tcx>,
    verus_items: std::sync::Arc<VerusItems>,
    krate: &'tcx Crate<'tcx>,
    emit_state: &mut EmitState,
    erasure_hints: &ErasureHints,
) -> State {
    let gen_state = crate::lifetime_generate::gen_check_tracked_lifetimes(
        cmd_line_args,
        tcx,
        verus_items,
        krate,
        erasure_hints,
    );
    for line in PRELUDE.split('\n') {
        emit_state.writeln(line.replace("\r", ""));
    }

    for t in gen_state.trait_decls.iter() {
        emit_trait_decl(emit_state, t);
    }
    for d in gen_state.datatype_decls.iter() {
        emit_datatype_decl(emit_state, d);
    }
    for (a, fns) in gen_state.assoc_type_impls.iter() {
        emit_assoc_type_impl(emit_state, a, fns);
    }
    for f in gen_state.fun_decls.iter() {
        emit_fun_decl(emit_state, f);
    }
    gen_state
}

struct LifetimeCallbacks {}

impl rustc_driver::Callbacks for LifetimeCallbacks {
    // TODO(&mut)
    fn config(&mut self, config: &mut rustc_interface::Config) {
        config.override_queries = Some(|_session, providers, _| {
            providers.mir_borrowck = |tcx, def_id| {
                let result = (rustc_interface::DEFAULT_QUERY_PROVIDERS.mir_borrowck)(tcx, def_id);
                // ldbg!(&def_id, &result);

                let opts = rustc_borrowck::consumers::ConsumerOptions::RegionInferenceContext;

                let body_with_facts =
                    rustc_borrowck::consumers::get_body_with_borrowck_facts(tcx, def_id, opts);

                let body = &body_with_facts.body;
                // for (i, d) in body.local_decls.iter().enumerate() {
                //     if false {
                //         if let (_, rustc_type_ir::TyKind::Ref(region, inner_ty, rustc_ast::Mutability::Mut)) = (d.is_user_variable(), d.ty.kind()) {
                //             ldbg!(&(i, &d.local_info, &region));
                //         }
                //     }
                //     leprintln!(format!("_{} {:?}", i, &d.local_info));
                // }
                // ldbg!(&body);
                let borrow_set = &body_with_facts.borrow_set;
                // ldbg!(&body_with_facts.borrow_set.location_map);
                let borrows_out_of_scope =
                    rustc_borrowck::consumers::calculate_borrows_out_of_scope_at_location(
                        &body_with_facts.body,
                        &body_with_facts.region_inference_context,
                        &borrow_set,
                    );
                // ldbg!(&borrows_out_of_scope);
                let mut resolved_at = std::collections::HashSet::new();
                for (bb, bbd) in rustc_middle::mir::traversal::reachable(&body) {
                    if let Some(terminator) = &bbd.terminator {
                        match &terminator.kind {
                            rustc_middle::mir::TerminatorKind::Call {
                                func,
                                args,
                                destination,
                                target,
                                unwind,
                                call_source,
                                fn_span,
                            } => {
                                if let rustc_middle::ty::TyKind::FnDef(fn_def_id, _) =
                                    func.ty(&body.local_decls, tcx).kind()
                                {
                                    if tcx.is_diagnostic_item(
                                        Symbol::intern("verus::lifetime::resolve"),
                                        *fn_def_id,
                                    ) {
                                        let rustc_middle::mir::Operand::Move(resolve_place) =
                                            &args[0]
                                        else {
                                            panic!("invalid resolve");
                                        };
                                        if let Some(target) = target {
                                            for (i, s) in
                                                body[*target].statements.iter().enumerate()
                                            {
                                                if matches!(s.kind, rustc_middle::mir::StatementKind::StorageDead(p) if p == resolve_place.local)
                                                {
                                                    let loc = rustc_middle::mir::Location {
                                                        block: *target,
                                                        statement_index: i,
                                                    };
                                                    resolved_at.insert(loc);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            _ => (),
                        }
                    }
                }
                // ldbg!(&resolved_at);
                for (i, bw) in body_with_facts.borrow_set.location_map.iter().enumerate() {
                    let local_span =
                        body.local_decls[bw.1.borrowed_place.local].source_info.span;
                    let borrowed_local_info = &**body.local_decls[bw.1.borrowed_place.local]
                        .local_info
                        .as_ref()
                        .assert_crate_local();
                    if let rustc_middle::mir::LocalInfo::User(local_binding_form) =
                        &borrowed_local_info
                    {
                        // TODO ???
                        // let mut resolved_immediately = false;
                        // if !matches!(&bw.1.activation_location, rustc_borrowck::borrow_set::TwoPhaseActivation::ActivatedAt(_)) {
                        //     for bos in borrows_out_of_scope.iter() {
                        //         if bos.1.iter().find(|bi| bi.as_usize() == i).is_some() {
                        //             if bos.0.block == bw.0.block {
                        //                 resolved_immediately = true;
                        //             }
                        //         }
                        //     }
                        // }
                        // if !resolved_immediately {
                        // if !matches!(&bw.1.activation_location, rustc_borrowck::borrow_set::TwoPhaseActivation::ActivatedAt(_)) {
                        let out_of_scope_at: Vec<_> = borrows_out_of_scope
                            .iter()
                            .filter_map(|bos| {
                                bos.1.iter().find(|bi| bi.as_usize() == i).map(|_| bos.0)
                            })
                            .filter(|loc| !body[loc.block].is_cleanup)
                            .collect();
                        fn span_to_diagnostic_span(
                            tcx: TyCtxt<'_>,
                            span: rustc_span::Span,
                        ) -> DiagnosticSpan {
                            let lo = tcx.sess.source_map().lookup_char_pos(span.lo());
                            let hi = tcx.sess.source_map().lookup_char_pos(span.hi());
                            DiagnosticSpan {
                                line_start: lo.line,
                                column_start: lo.col.0,
                                line_end: hi.line,
                                column_end: hi.col.0,
                            }
                        }
                        for loc in out_of_scope_at.iter() {
                            if loc.block != bw.0.block && !resolved_at.contains(loc) {
                                // ldbg!(&(
                                //     format!("NOT RESOLVED: bw{}", i),
                                //     bw,
                                //     bw.1.borrowed_place.local,
                                //     borrowed_local_info,
                                //     bw.1.region,
                                //     &out_of_scope_at
                                // ));
                                let mut spans = vec![span_to_diagnostic_span(tcx, local_span)];
                                if let Some(terminator) =
                                    &body[bw.1.reserve_location.block].terminator
                                {
                                    spans.push(span_to_diagnostic_span(
                                        tcx,
                                        terminator.source_info.span,
                                    ));
                                }
                                // TODO? match local_binding_form {
                                // TODO?     rustc_middle::mir::BindingForm::Var(VarBindingForm { opt_match_place: Some((_, var_span)), .. }) => {
                                // TODO?     }
                                // TODO?     rustc_middle::mir::BindingForm::ImplicitSelf(_) => {
                                // TODO?         // TODO emit a span for self?
                                // TODO?     }
                                // TODO?     _ => (),
                                // TODO? }
                                let d = Diagnostic {
                                    message: format!(
                                        "a mutable borrow that lives more than a single statement was not explicitly resolved"
                                    ),
                                    level: format!("error"),
                                    spans,
                                };
                                eprintln!(
                                    "{}",
                                    serde_json::to_string(&d)
                                        .expect("cannot serialize resolve diagnostic")
                                );
                            }
                        }
                        // }
                        // }
                    }
                }
                // match &body_with_facts.borrow_set.locals_state_at_exit {
                //     rustc_borrowck::borrow_set::LocalsStateAtExit::AllAreInvalidated => {},
                //     rustc_borrowck::borrow_set::LocalsStateAtExit::SomeAreInvalidated { has_storage_dead_or_moved } => {
                //         ldbg!(&has_storage_dead_or_moved);
                //     }
                // }
                // ldbg!(&body.basic_blocks);
                if false {
                    let mir_pretty = {
                        let mut s: Vec<u8> = Vec::new();
                        let w: &mut dyn Write = &mut s;
                        rustc_middle::mir::pretty::write_mir_fn(
                            tcx,
                            body,
                            &mut |_, _| Ok(()),
                            w,
                        )
                        .expect("error pretty mir");
                        String::from_utf8(s).expect("invalid utf8")
                    };
                    leprintln!(&mir_pretty);
                }

                if false {
                    let mut debug_output = String::new();
                    use std::fmt::Write;
                    writeln!(&mut debug_output, "maybe_live");

                    for (bb, bbd) in rustc_middle::mir::traversal::reachable(&body) {
                        if bbd.is_cleanup {
                            writeln!(&mut debug_output, "{:?} (cleanup)", &bb);
                            continue;
                        }
                        writeln!(&mut debug_output, "{:?}", &bb);
                        let mut loc = bb.start_location();
                        for (s, statement) in bbd.statements.iter().enumerate() {
                            writeln!(&mut debug_output, "    [{}] {:?}", &s, &statement);
                            loc = loc.successor_within_block();
                        }
                        writeln!(&mut debug_output, "    {:?}", &bbd.terminator().kind);
                    }

                    leprintln!(&debug_output);
                }

                result
            };
        });
    }

    fn after_parsing<'tcx>(
        &mut self,
        _compiler: &rustc_interface::interface::Compiler,
        queries: &'tcx rustc_interface::Queries<'tcx>,
    ) -> rustc_driver::Compilation {
        check(queries);
        rustc_driver::Compilation::Stop
    }
}

struct LifetimeFileLoader {
    rust_code: String,
}

impl LifetimeFileLoader {
    const FILENAME: &'static str = "dummyrs.rs";
}

impl rustc_span::source_map::FileLoader for LifetimeFileLoader {
    fn file_exists(&self, _path: &std::path::Path) -> bool {
        panic!("unexpected call to file_exists")
    }

    fn read_file(&self, path: &std::path::Path) -> Result<String, std::io::Error> {
        assert!(path.display().to_string() == Self::FILENAME.to_string());
        Ok(self.rust_code.clone())
    }

    fn read_binary_file(&self, path: &std::path::Path) -> Result<Vec<u8>, std::io::Error> {
        assert!(path.display().to_string() == Self::FILENAME.to_string());
        Ok(self.rust_code.clone().into_bytes())
    }
}

#[derive(Debug, Serialize, Deserialize)]
struct DiagnosticSpan {
    line_start: usize,
    line_end: usize,
    column_start: usize,
    column_end: usize,
}

#[derive(Debug, Serialize, Deserialize)]
struct Diagnostic {
    message: String,
    level: String,
    spans: Vec<DiagnosticSpan>,
}

pub const LIFETIME_DRIVER_ARG: &'static str = "--internal-lifetime-driver";

pub fn lifetime_rustc_driver(rustc_args: &[String], rust_code: String) {
    let mut callbacks = LifetimeCallbacks {};
    let mut compiler = rustc_driver::RunCompiler::new(rustc_args, &mut callbacks);
    compiler.set_file_loader(Some(Box::new(LifetimeFileLoader { rust_code })));
    match compiler.run() {
        Ok(()) => (),
        Err(_) => std::process::exit(128),
    }
}

pub(crate) fn check_tracked_lifetimes<'tcx>(
    cmd_line_args: crate::config::Args,
    tcx: TyCtxt<'tcx>,
    verus_items: std::sync::Arc<VerusItems>,
    spans: &SpanContext,
    erasure_hints: &ErasureHints,
    lifetime_log_file: Option<File>,
) -> Result<Vec<Message>, VirErr> {
    let krate = tcx.hir().krate();
    let mut emit_state = EmitState::new();
    let gen_state = emit_check_tracked_lifetimes(
        cmd_line_args,
        tcx,
        verus_items,
        krate,
        &mut emit_state,
        erasure_hints,
    );
    let mut rust_code: String = String::new();
    for line in &emit_state.lines {
        rust_code.push_str(&line.text);
        rust_code.push('\n');
    }
    if let Some(mut file) = lifetime_log_file {
        write!(file, "{}", &rust_code).expect("error writing to lifetime log file");
    }
    let rustc_args = vec![LIFETIME_DRIVER_ARG, LifetimeFileLoader::FILENAME, "--error-format=json"];

    let mut child = std::process::Command::new(std::env::current_exe().unwrap())
        .args(&rustc_args[..])
        .stdin(std::process::Stdio::piped())
        .stdout(std::process::Stdio::piped())
        // TODO(&mut)
        .stderr(std::process::Stdio::piped())
        .spawn()
        .expect("could not execute lifetime rustc process");
    let mut child_stdin = child.stdin.take().expect("take stdin");
    // std::fs::write("/tmp/verus_lifetime_generate.rs", rust_code.clone()).unwrap();
    child_stdin.write(rust_code.as_bytes()).expect("failed to send code to lifetime rustc");
    std::mem::drop(child_stdin);
    let run = child.wait_with_output().expect("lifetime rustc wait failed");
    let rust_output = std::str::from_utf8(&run.stderr[..]).unwrap().trim();
    let mut msgs: Vec<Message> = Vec::new();
    let debug = false;
    if rust_output.len() > 0 {
        for ss in rust_output.split("\n") {
            if let Some(ss) = ss.strip_prefix(LDBG_PREFIX) {
                eprintln!("{}", ss);
            } else {
                let diag: Diagnostic = serde_json::from_str(ss).expect("serde_json from_str");
                if diag.level == "failure-note" {
                    continue;
                }
                if diag.level == "warning" {
                    dbg!("internal error: unexpected warning");
                    dbg!(diag);
                    continue;
                }
                assert!(diag.level == "error");
                let msg_text = gen_state.unmangle_names(&diag.message);
                let mut msg = message_bare(MessageLevel::Error, &msg_text);
                if debug {
                    dbg!(&msg);
                }
                for dspan in &diag.spans {
                    if debug {
                        dbg!(&dspan);
                    }
                    let span = emit_state.get_span(
                        dspan.line_start - 1,
                        dspan.column_start - 1,
                        dspan.line_end - 1,
                        dspan.column_end - 1,
                    );
                    msg = msg.primary_span(&spans.to_air_span(span));
                }
                msgs.push(msg);
            }
        }
    }
    if debug {
        dbg!(msgs.len());
    }
    if msgs.len() == 0 && !run.status.success() {
        Err(error("lifetime checking failed"))
    } else {
        Ok(msgs)
    }
}
